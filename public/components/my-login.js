/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = window, i = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s = Symbol(), e = new WeakMap; class n { constructor(t, i, e) { if (this._$cssResult$ = !0, e !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead."); this.cssText = t, this.t = i } get styleSheet() { let t = this.o; const s = this.t; if (i && void 0 === t) { const i = void 0 !== s && 1 === s.length; i && (t = e.get(s)), void 0 === t && ((this.o = t = new CSSStyleSheet).replaceSync(this.cssText), i && e.set(s, t)) } return t } toString() { return this.cssText } } const o = i ? t => t : t => t instanceof CSSStyleSheet ? (t => { let i = ""; for (const s of t.cssRules) i += s.cssText; return (t => new n("string" == typeof t ? t : t + "", void 0, s))(i) })(t) : t
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */; var r; const h = window, l = h.trustedTypes, d = l ? l.emptyScript : "", a = h.reactiveElementPolyfillSupport, c = { toAttribute(t, i) { switch (i) { case Boolean: t = t ? d : null; break; case Object: case Array: t = null == t ? t : JSON.stringify(t) }return t }, fromAttribute(t, i) { let s = t; switch (i) { case Boolean: s = null !== t; break; case Number: s = null === t ? null : Number(t); break; case Object: case Array: try { s = JSON.parse(t) } catch (t) { s = null } }return s } }, u = (t, i) => i !== t && (i == i || t == t), v = { attribute: !0, type: String, converter: c, reflect: !1, hasChanged: u }; class f extends HTMLElement { constructor() { super(), this._$Ei = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this.u() } static addInitializer(t) { var i; this.finalize(), (null !== (i = this.h) && void 0 !== i ? i : this.h = []).push(t) } static get observedAttributes() { this.finalize(); const t = []; return this.elementProperties.forEach(((i, s) => { const e = this._$Ep(s, i); void 0 !== e && (this._$Ev.set(e, s), t.push(e)) })), t } static createProperty(t, i = v) { if (i.state && (i.attribute = !1), this.finalize(), this.elementProperties.set(t, i), !i.noAccessor && !this.prototype.hasOwnProperty(t)) { const s = "symbol" == typeof t ? Symbol() : "__" + t, e = this.getPropertyDescriptor(t, s, i); void 0 !== e && Object.defineProperty(this.prototype, t, e) } } static getPropertyDescriptor(t, i, s) { return { get() { return this[ i ] }, set(e) { const n = this[ t ]; this[ i ] = e, this.requestUpdate(t, n, s) }, configurable: !0, enumerable: !0 } } static getPropertyOptions(t) { return this.elementProperties.get(t) || v } static finalize() { if (this.hasOwnProperty("finalized")) return !1; this.finalized = !0; const t = Object.getPrototypeOf(this); if (t.finalize(), void 0 !== t.h && (this.h = [ ...t.h ]), this.elementProperties = new Map(t.elementProperties), this._$Ev = new Map, this.hasOwnProperty("properties")) { const t = this.properties, i = [ ...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t) ]; for (const s of i) this.createProperty(s, t[ s ]) } return this.elementStyles = this.finalizeStyles(this.styles), !0 } static finalizeStyles(t) { const i = []; if (Array.isArray(t)) { const s = new Set(t.flat(1 / 0).reverse()); for (const t of s) i.unshift(o(t)) } else void 0 !== t && i.push(o(t)); return i } static _$Ep(t, i) { const s = i.attribute; return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0 } u() { var t; this._$E_ = new Promise((t => this.enableUpdating = t)), this._$AL = new Map, this._$Eg(), this.requestUpdate(), null === (t = this.constructor.h) || void 0 === t || t.forEach((t => t(this))) } addController(t) { var i, s; (null !== (i = this._$ES) && void 0 !== i ? i : this._$ES = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t)) } removeController(t) { var i; null === (i = this._$ES) || void 0 === i || i.splice(this._$ES.indexOf(t) >>> 0, 1) } _$Eg() { this.constructor.elementProperties.forEach(((t, i) => { this.hasOwnProperty(i) && (this._$Ei.set(i, this[ i ]), delete this[ i ]) })) } createRenderRoot() { var s; const e = null !== (s = this.shadowRoot) && void 0 !== s ? s : this.attachShadow(this.constructor.shadowRootOptions); return ((s, e) => { i ? s.adoptedStyleSheets = e.map((t => t instanceof CSSStyleSheet ? t : t.styleSheet)) : e.forEach((i => { const e = document.createElement("style"), n = t.litNonce; void 0 !== n && e.setAttribute("nonce", n), e.textContent = i.cssText, s.appendChild(e) })) })(e, this.constructor.elementStyles), e } connectedCallback() { var t; void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$ES) || void 0 === t || t.forEach((t => { var i; return null === (i = t.hostConnected) || void 0 === i ? void 0 : i.call(t) })) } enableUpdating(t) { } disconnectedCallback() { var t; null === (t = this._$ES) || void 0 === t || t.forEach((t => { var i; return null === (i = t.hostDisconnected) || void 0 === i ? void 0 : i.call(t) })) } attributeChangedCallback(t, i, s) { this._$AK(t, s) } _$EO(t, i, s = v) { var e; const n = this.constructor._$Ep(t, s); if (void 0 !== n && !0 === s.reflect) { const o = (void 0 !== (null === (e = s.converter) || void 0 === e ? void 0 : e.toAttribute) ? s.converter : c).toAttribute(i, s.type); this._$El = t, null == o ? this.removeAttribute(n) : this.setAttribute(n, o), this._$El = null } } _$AK(t, i) { var s; const e = this.constructor, n = e._$Ev.get(t); if (void 0 !== n && this._$El !== n) { const t = e.getPropertyOptions(n), o = "function" == typeof t.converter ? { fromAttribute: t.converter } : void 0 !== (null === (s = t.converter) || void 0 === s ? void 0 : s.fromAttribute) ? t.converter : c; this._$El = n, this[ n ] = o.fromAttribute(i, t.type), this._$El = null } } requestUpdate(t, i, s) { let e = !0; void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || u)(this[ t ], i) ? (this._$AL.has(t) || this._$AL.set(t, i), !0 === s.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t, s))) : e = !1), !this.isUpdatePending && e && (this._$E_ = this._$Ej()) } async _$Ej() { this.isUpdatePending = !0; try { await this._$E_ } catch (t) { Promise.reject(t) } const t = this.scheduleUpdate(); return null != t && await t, !this.isUpdatePending } scheduleUpdate() { return this.performUpdate() } performUpdate() { var t; if (!this.isUpdatePending) return; this.hasUpdated, this._$Ei && (this._$Ei.forEach(((t, i) => this[ i ] = t)), this._$Ei = void 0); let i = !1; const s = this._$AL; try { i = this.shouldUpdate(s), i ? (this.willUpdate(s), null === (t = this._$ES) || void 0 === t || t.forEach((t => { var i; return null === (i = t.hostUpdate) || void 0 === i ? void 0 : i.call(t) })), this.update(s)) : this._$Ek() } catch (t) { throw i = !1, this._$Ek(), t } i && this._$AE(s) } willUpdate(t) { } _$AE(t) { var i; null === (i = this._$ES) || void 0 === i || i.forEach((t => { var i; return null === (i = t.hostUpdated) || void 0 === i ? void 0 : i.call(t) })), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t) } _$Ek() { this._$AL = new Map, this.isUpdatePending = !1 } get updateComplete() { return this.getUpdateComplete() } getUpdateComplete() { return this._$E_ } shouldUpdate(t) { return !0 } update(t) { void 0 !== this._$EC && (this._$EC.forEach(((t, i) => this._$EO(i, this[ i ], t))), this._$EC = void 0), this._$Ek() } updated(t) { } firstUpdated(t) { } }
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var p; f.finalized = !0, f.elementProperties = new Map, f.elementStyles = [], f.shadowRootOptions = { mode: "open" }, null == a || a({ ReactiveElement: f }), (null !== (r = h.reactiveElementVersions) && void 0 !== r ? r : h.reactiveElementVersions = []).push("1.6.1"); const w = window, g = w.trustedTypes, y = g ? g.createPolicy("lit-html", { createHTML: t => t }) : void 0, b = `lit$${(Math.random() + "").slice(9)}$`, m = "?" + b, $ = `<${m}>`, S = document, A = (t = "") => S.createComment(t), E = t => null === t || "object" != typeof t && "function" != typeof t, C = Array.isArray, x = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, _ = /-->/g, k = />/g, j = RegExp(">|[ \t\n\f\r](?:([^\\s\"'>=/]+)([ \t\n\f\r]*=[ \t\n\f\r]*(?:[^ \t\n\f\r\"'`<>=]|(\"|')|))|$)", "g"), U = /'/g, O = /"/g, M = /^(?:script|style|textarea|title)$/i, T = (t => (i, ...s) => ({ _$litType$: t, strings: i, values: s }))(1), L = Symbol.for("lit-noChange"), N = Symbol.for("lit-nothing"), R = new WeakMap, z = S.createTreeWalker(S, 129, null, !1), I = (t, i) => { const s = t.length - 1, e = []; let n, o = 2 === i ? "<svg>" : "", r = x; for (let i = 0; i < s; i++) { const s = t[ i ]; let h, l, d = -1, a = 0; for (; a < s.length && (r.lastIndex = a, l = r.exec(s), null !== l);)a = r.lastIndex, r === x ? "!--" === l[ 1 ] ? r = _ : void 0 !== l[ 1 ] ? r = k : void 0 !== l[ 2 ] ? (M.test(l[ 2 ]) && (n = RegExp("</" + l[ 2 ], "g")), r = j) : void 0 !== l[ 3 ] && (r = j) : r === j ? ">" === l[ 0 ] ? (r = null != n ? n : x, d = -1) : void 0 === l[ 1 ] ? d = -2 : (d = r.lastIndex - l[ 2 ].length, h = l[ 1 ], r = void 0 === l[ 3 ] ? j : '"' === l[ 3 ] ? O : U) : r === O || r === U ? r = j : r === _ || r === k ? r = x : (r = j, n = void 0); const c = r === j && t[ i + 1 ].startsWith("/>") ? " " : ""; o += r === x ? s + $ : d >= 0 ? (e.push(h), s.slice(0, d) + "$lit$" + s.slice(d) + b + c) : s + b + (-2 === d ? (e.push(void 0), i) : c) } const h = o + (t[ s ] || "<?>") + (2 === i ? "</svg>" : ""); if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array"); return [ void 0 !== y ? y.createHTML(h) : h, e ] }; class P { constructor({ strings: t, _$litType$: i }, s) { let e; this.parts = []; let n = 0, o = 0; const r = t.length - 1, h = this.parts, [ l, d ] = I(t, i); if (this.el = P.createElement(l, s), z.currentNode = this.el.content, 2 === i) { const t = this.el.content, i = t.firstChild; i.remove(), t.append(...i.childNodes) } for (; null !== (e = z.nextNode()) && h.length < r;) { if (1 === e.nodeType) { if (e.hasAttributes()) { const t = []; for (const i of e.getAttributeNames()) if (i.endsWith("$lit$") || i.startsWith(b)) { const s = d[ o++ ]; if (t.push(i), void 0 !== s) { const t = e.getAttribute(s.toLowerCase() + "$lit$").split(b), i = /([.?@])?(.*)/.exec(s); h.push({ type: 1, index: n, name: i[ 2 ], strings: t, ctor: "." === i[ 1 ] ? Z : "?" === i[ 1 ] ? q : "@" === i[ 1 ] ? J : V }) } else h.push({ type: 6, index: n }) } for (const i of t) e.removeAttribute(i) } if (M.test(e.tagName)) { const t = e.textContent.split(b), i = t.length - 1; if (i > 0) { e.textContent = g ? g.emptyScript : ""; for (let s = 0; s < i; s++)e.append(t[ s ], A()), z.nextNode(), h.push({ type: 2, index: ++n }); e.append(t[ i ], A()) } } } else if (8 === e.nodeType) if (e.data === m) h.push({ type: 2, index: n }); else { let t = -1; for (; -1 !== (t = e.data.indexOf(b, t + 1));)h.push({ type: 7, index: n }), t += b.length - 1 } n++ } } static createElement(t, i) { const s = S.createElement("template"); return s.innerHTML = t, s } } function B(t, i, s = t, e) { var n, o, r, h; if (i === L) return i; let l = void 0 !== e ? null === (n = s._$Co) || void 0 === n ? void 0 : n[ e ] : s._$Cl; const d = E(i) ? void 0 : i._$litDirective$; return (null == l ? void 0 : l.constructor) !== d && (null === (o = null == l ? void 0 : l._$AO) || void 0 === o || o.call(l, !1), void 0 === d ? l = void 0 : (l = new d(t), l._$AT(t, s, e)), void 0 !== e ? (null !== (r = (h = s)._$Co) && void 0 !== r ? r : h._$Co = [])[ e ] = l : s._$Cl = l), void 0 !== l && (i = B(t, l._$AS(t, i.values), l, e)), i } class H { constructor(t, i) { this.u = [], this._$AN = void 0, this._$AD = t, this._$AM = i } get parentNode() { return this._$AM.parentNode } get _$AU() { return this._$AM._$AU } v(t) { var i; const { el: { content: s }, parts: e } = this._$AD, n = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : S).importNode(s, !0); z.currentNode = n; let o = z.nextNode(), r = 0, h = 0, l = e[ 0 ]; for (; void 0 !== l;) { if (r === l.index) { let i; 2 === l.type ? i = new K(o, o.nextSibling, this, t) : 1 === l.type ? i = new l.ctor(o, l.name, l.strings, this, t) : 6 === l.type && (i = new W(o, this, t)), this.u.push(i), l = e[ ++h ] } r !== (null == l ? void 0 : l.index) && (o = z.nextNode(), r++) } return n } p(t) { let i = 0; for (const s of this.u) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[ i ])), i++ } } class K { constructor(t, i, s, e) { var n; this.type = 2, this._$AH = N, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cm = null === (n = null == e ? void 0 : e.isConnected) || void 0 === n || n } get _$AU() { var t, i; return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cm } get parentNode() { let t = this._$AA.parentNode; const i = this._$AM; return void 0 !== i && 11 === t.nodeType && (t = i.parentNode), t } get startNode() { return this._$AA } get endNode() { return this._$AB } _$AI(t, i = this) { t = B(this, t, i), E(t) ? t === N || null == t || "" === t ? (this._$AH !== N && this._$AR(), this._$AH = N) : t !== this._$AH && t !== L && this.g(t) : void 0 !== t._$litType$ ? this.$(t) : void 0 !== t.nodeType ? this.T(t) : (t => C(t) || "function" == typeof (null == t ? void 0 : t[ Symbol.iterator ]))(t) ? this.k(t) : this.g(t) } O(t, i = this._$AB) { return this._$AA.parentNode.insertBefore(t, i) } T(t) { this._$AH !== t && (this._$AR(), this._$AH = this.O(t)) } g(t) { this._$AH !== N && E(this._$AH) ? this._$AA.nextSibling.data = t : this.T(S.createTextNode(t)), this._$AH = t } $(t) { var i; const { values: s, _$litType$: e } = t, n = "number" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = P.createElement(e.h, this.options)), e); if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === n) this._$AH.p(s); else { const t = new H(n, this), i = t.v(this.options); t.p(s), this.T(i), this._$AH = t } } _$AC(t) { let i = R.get(t.strings); return void 0 === i && R.set(t.strings, i = new P(t)), i } k(t) { C(this._$AH) || (this._$AH = [], this._$AR()); const i = this._$AH; let s, e = 0; for (const n of t) e === i.length ? i.push(s = new K(this.O(A()), this.O(A()), this, this.options)) : s = i[ e ], s._$AI(n), e++; e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e) } _$AR(t = this._$AA.nextSibling, i) { var s; for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) { const i = t.nextSibling; t.remove(), t = i } } setConnected(t) { var i; void 0 === this._$AM && (this._$Cm = t, null === (i = this._$AP) || void 0 === i || i.call(this, t)) } } class V { constructor(t, i, s, e, n) { this.type = 1, this._$AH = N, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = n, s.length > 2 || "" !== s[ 0 ] || "" !== s[ 1 ] ? (this._$AH = Array(s.length - 1).fill(new String), this.strings = s) : this._$AH = N } get tagName() { return this.element.tagName } get _$AU() { return this._$AM._$AU } _$AI(t, i = this, s, e) { const n = this.strings; let o = !1; if (void 0 === n) t = B(this, t, i, 0), o = !E(t) || t !== this._$AH && t !== L, o && (this._$AH = t); else { const e = t; let r, h; for (t = n[ 0 ], r = 0; r < n.length - 1; r++)h = B(this, e[ s + r ], i, r), h === L && (h = this._$AH[ r ]), o || (o = !E(h) || h !== this._$AH[ r ]), h === N ? t = N : t !== N && (t += (null != h ? h : "") + n[ r + 1 ]), this._$AH[ r ] = h } o && !e && this.j(t) } j(t) { t === N ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "") } } class Z extends V { constructor() { super(...arguments), this.type = 3 } j(t) { this.element[ this.name ] = t === N ? void 0 : t } } const D = g ? g.emptyScript : ""; class q extends V { constructor() { super(...arguments), this.type = 4 } j(t) { t && t !== N ? this.element.setAttribute(this.name, D) : this.element.removeAttribute(this.name) } } class J extends V { constructor(t, i, s, e, n) { super(t, i, s, e, n), this.type = 5 } _$AI(t, i = this) { var s; if ((t = null !== (s = B(this, t, i, 0)) && void 0 !== s ? s : N) === L) return; const e = this._$AH, n = t === N && e !== N || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive, o = t !== N && (e === N || n); n && this.element.removeEventListener(this.name, this, e), o && this.element.addEventListener(this.name, this, t), this._$AH = t } handleEvent(t) { var i, s; "function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t) } } class W { constructor(t, i, s) { this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s } get _$AU() { return this._$AM._$AU } _$AI(t) { B(this, t) } } const F = w.litHtmlPolyfillSupport; null == F || F(P, K), (null !== (p = w.litHtmlVersions) && void 0 !== p ? p : w.litHtmlVersions = []).push("2.6.1");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var G, Q; class X extends f { constructor() { super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0 } createRenderRoot() { var t, i; const s = super.createRenderRoot(); return null !== (t = (i = this.renderOptions).renderBefore) && void 0 !== t || (i.renderBefore = s.firstChild), s } update(t) { const i = this.render(); this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = ((t, i, s) => { var e, n; const o = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i; let r = o._$litPart$; if (void 0 === r) { const t = null !== (n = null == s ? void 0 : s.renderBefore) && void 0 !== n ? n : null; o._$litPart$ = r = new K(i.insertBefore(A(), t), t, void 0, null != s ? s : {}) } return r._$AI(t), r })(i, this.renderRoot, this.renderOptions) } connectedCallback() { var t; super.connectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!0) } disconnectedCallback() { var t; super.disconnectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!1) } render() { return L } } X.finalized = !0, X._$litElement$ = !0, null === (G = globalThis.litElementHydrateSupport) || void 0 === G || G.call(globalThis, { LitElement: X }); const Y = globalThis.litElementPolyfillSupport; null == Y || Y({ LitElement: X }), (null !== (Q = globalThis.litElementVersions) && void 0 !== Q ? Q : globalThis.litElementVersions = []).push("3.2.2");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const tt = (t, i) => "method" === i.kind && i.descriptor && !("value" in i.descriptor) ? { ...i, finisher(s) { s.createProperty(i.key, t) } } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: i.key, initializer() { "function" == typeof i.initializer && (this[ i.key ] = i.initializer.call(this)) }, finisher(s) { s.createProperty(i.key, t) } };
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function it(t) {
  return (i, s) => void 0 !== s ? ((t, i, s) => { i.constructor.createProperty(s, t) })(t, i, s) : tt(t, i)
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */} var st; null === (st = window.HTMLSlotElement) || void 0 === st || st.prototype.assignedElements; var et = function (t, i, s, e) { for (var n, o = arguments.length, r = o < 3 ? i : null === e ? e = Object.getOwnPropertyDescriptor(i, s) : e, h = t.length - 1; h >= 0; h--)(n = t[ h ]) && (r = (o < 3 ? n(r) : o > 3 ? n(i, s, r) : n(i, s)) || r); return o > 3 && r && Object.defineProperty(i, s, r), r }; let nt = class extends X {
  constructor() { super(...arguments), this.isLoggedIn = !1, this.authClient = null, this.initAuth0SDK = async () => { console.log("Auth0 SDK loaded"), await this.initiateAuth0Client(), await this.checkForAuth0Auth() }, this.initiateAuth0Client = async () => { console.log("Creating Auth0 Client"); const t = await window.auth0.createAuth0Client({ domain: "dev-0ankmncvvc0wyqw3.us.auth0.com", clientId: "BGUawZrKEx7LFVQAwxe25dtVTVyfAZHy" }); this.authClient = t, window.authClient = t }, this.login = async () => { var t, i; try { if (await (null === (t = this.authClient) || void 0 === t ? void 0 : t.isAuthenticated())) return console.log("User is authenticated"), this.isLoggedIn = !0, void window.dispatchEvent(new Event("login")); const s = { authorizationParams: { redirect_uri: `${window.location.origin}/components-test.html` } }; await (null === (i = this.authClient) || void 0 === i ? void 0 : i.loginWithRedirect(s)) } catch (t) { this.isLoggedIn = !1, console.log("Log in failed", t), window.dispatchEvent(new Event("logout")) } }, this.checkForAuth0Auth = async () => { var t; if (await (null === (t = this.authClient) || void 0 === t ? void 0 : t.isAuthenticated())) return this.isLoggedIn = !0, window.dispatchEvent(new Event("login")), void console.log("User is already authenticated"); if (window.location.search.includes("code=") && this.authClient) { console.log("Parsing redirect code"); try { await this.authClient.handleRedirectCallback(), this.isLoggedIn = !0, window.dispatchEvent(new Event("login")), console.log("Logged in!") } catch (t) { console.log("Error with redirect code:", t), this.isLoggedIn = !1, window.dispatchEvent(new Event("logout")) } window.history.replaceState({}, document.title, "/components-test.html") } } } connectedCallback() { super.connectedCallback(); const t = document.createElement("script"); t.type = "text/javascript", t.async = !0, t.onload = this.initAuth0SDK, t.src = "https://cdn.auth0.com/js/auth0-spa-js/2.0/auth0-spa-js.production.js", document.head.appendChild(t) } render() {
    return T`<button
      @click=${this.login}
      ?disabled=${!!this.isLoggedIn || void 0}
      part="button"
    >
      Login
    </button> `}
}; nt.styles = ((t, ...i) => { const e = 1 === t.length ? t[ 0 ] : i.reduce(((i, s, e) => i + (t => { if (!0 === t._$cssResult$) return t.cssText; if ("number" == typeof t) return t; throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.") })(s) + t[ e + 1 ]), t[ 0 ]); return new n(e, t, s) })`
    :host {
      padding: 30px;
    }

    button {
      font-family: 'Helvetica';
      border: solid 1px #222;
      padding: 10px;
      background: rgba(34, 34, 34, 0.8);
      color: white;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    button:hover:not(:disabled) {
      cursor: pointer;
    }

    button:active {
      background: rgba(34, 34, 34, 0.2);
      color: #222;
    }
  `, et([ it({ type: Boolean }) ], nt.prototype, "isLoggedIn", void 0), et([ it() ], nt.prototype, "authClient", void 0), nt = et([ (t => i => "function" == typeof i ? ((t, i) => (customElements.define(t, i), i))(t, i) : ((t, i) => { const { kind: s, elements: e } = i; return { kind: s, elements: e, finisher(i) { customElements.define(t, i) } } })(t, i))("my-login") ], nt); export { nt as MyElement };
